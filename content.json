{"meta":{"title":"codeMario","subtitle":"逆风赶路，不负众望","description":"","author":"codeMario","url":"https://codemariosec.github.io","root":"/"},"pages":[{"title":"[404]","date":"2022-01-30T03:45:54.882Z","updated":"2022-01-30T03:45:54.882Z","comments":true,"path":"404/index.html","permalink":"https://codemariosec.github.io/404/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-03T06:50:33.696Z","updated":"2022-06-03T06:50:33.696Z","comments":true,"path":"tags/index.html","permalink":"https://codemariosec.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-06-03T06:50:42.572Z","updated":"2022-06-03T06:50:42.572Z","comments":true,"path":"categories/index.html","permalink":"https://codemariosec.github.io/categories/index.html","excerpt":"","text":""},{"title":"ABOUT ME","date":"2022-05-07T01:33:34.401Z","updated":"2022-05-07T01:33:34.401Z","comments":true,"path":"about/index.html","permalink":"https://codemariosec.github.io/about/index.html","excerpt":"","text":"关于我​ 大幻想主义家，在coding的道路上跌跌撞撞的安全爱好者，喜欢分享自己的学习心得，记录一些美好瞬间。 ​ 博客园：https://www.cnblogs.com/codemariosec ​ 邮箱：&#x4a;&#x33;&#56;&#53;&#50;&#x35;&#49;&#54;&#57;&#51;&#x40;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d; ​ “三人行，必有我师焉”，欢迎各位前来交流，一起学习，一起成长。 ​ 很喜欢这样一句话：“成功不是将来才有的，而是从决定那一刻起，持续积累而成”。 ​ 愿我们都能点满属于自己的目标技能树。"}],"posts":[{"title":"","slug":"1-1 集合的概念","date":"2022-06-10T13:58:34.694Z","updated":"2022-06-10T13:58:22.926Z","comments":true,"path":"2022/06/10/1-1 集合的概念/","link":"","permalink":"https://codemariosec.github.io/2022/06/10/1-1%20%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E5%BF%B5/","excerpt":"","text":"一、集合的定义具有某一个特定属性的，确定的，有区别的事物(不论是抽象的还是具体的)的全体称为集合，集合中的事物称为元素若a是集合A中的元素，记为a∈A若a不是集合A中的元素，记为a∉A 二、集合的特点 确定性 互异性 无序性 三、集合举例 某个特定的时间点上，某小区的所有商品房。 某个特定的时间点上，某个城市的所有树木的种类。 全体实数、全体无理数。 大于2且小于3的实数。 四、非集合举例 100个同批次型号的乒乓球–不满足集合元素的互异性。 一个城市的好人–不满足确定性。 五、数集与点集 集合中的元素是数,整数、自然数、正数、有理数、无理数 集合中的元素是坐标系中的点 ，{(x,y)|x+y&lt; 3}、{(x,y)| $x^{2}$ +y2&#x3D;3}、{(x,y)|x2+y2≤ 3}","categories":[],"tags":[]},{"title":"Pcap文件详解","slug":"pcap文件格式详解","date":"2022-05-12T07:49:38.000Z","updated":"2022-06-03T06:53:50.330Z","comments":true,"path":"2022/05/12/pcap文件格式详解/","link":"","permalink":"https://codemariosec.github.io/2022/05/12/pcap%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/","excerpt":"Pcap文件详解一、简介​ pcap文件是一种常用的数据报存储格式，里面的数据按照特定的规格存储和解析。 ​ 一般来说使用普通的笔记本打开的pcap文件显示的是乱码，所以我们需要使用支持16进制格式的工具去查看该文件，这里使用https://hexed.it/ 这个在线网站去查看。","text":"Pcap文件详解一、简介​ pcap文件是一种常用的数据报存储格式，里面的数据按照特定的规格存储和解析。 ​ 一般来说使用普通的笔记本打开的pcap文件显示的是乱码，所以我们需要使用支持16进制格式的工具去查看该文件，这里使用https://hexed.it/ 这个在线网站去查看。 二、文件格式 ​ pcag文件格式主要是由文件头-数据包头1-数据包1-数据包头2-数据包2这类格式组成。其中文件头只有一个，数据包头和数据包可以有多个，如下图所示。 ​ 每个pcap文件只有一个文件头，里面包含7个字段，总共占24(B)字节。 1.Pcap Header header field size explain Magic 4B 标记文件开始，并用来识别文件和字节顺序 Major 2B 当前Pcap文件的主要版本号，一般为0x0200 Minor 2B 当前Pcap文件的次要版本号，一般为0x0400 ThisZone 4B 当地的标准事件，如果用的是GMT则全零，一般全零 SigFlags 4B 时间戳的精度，一般为全零 SnapLen 4B 所抓获的数据包的最大长度 LinkType 4B 数据链路类型 2.Packet Header header field size explain Timestamp 4B 时间戳高位，精确到seconds Timestamp 4B 时间戳低位，能够精确到microseconds Caplen 4B 即抓取到的数据帧长度，由此可以得到下一个数据帧的位置。 Len 4B 实际的数据帧长度 3.Packet Data​ Packet是链路层的数据帧，其长度是Packet Header中定义的Caplen值，所以Packet Data的长度为Caplen。 4.案例​ 打开文件后如图所示（这里截取前面的部分） Pcap Header header field value Magic 0XD4C3B2A1 Major 0X0002 Minor 0X0004 ThisZone 0X00000000 SigFlags 0X00000000 SnapLen 0X00040000 LinkType 0X00000001 Packet Header header field value Timestamp 0X6279C37B Timestamp 0X0009EDB4 Caplen 0X00000042 Len 0X00000042 Packet Data ​ 数据包大小为0X00000042 &#x3D; 66B","categories":[{"name":"网络","slug":"网络","permalink":"https://codemariosec.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"Pcap","slug":"Pcap","permalink":"https://codemariosec.github.io/tags/Pcap/"}]},{"title":"Linux操作系统密码破解","slug":"Linux操作系统密码破解","date":"2022-01-30T18:11:51.000Z","updated":"2022-06-03T06:53:27.784Z","comments":true,"path":"2022/01/31/Linux操作系统密码破解/","link":"","permalink":"https://codemariosec.github.io/2022/01/31/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/","excerpt":"注：该文章中使用到的方法只用于学习交流，切勿用于非法途径！！！","text":"注：该文章中使用到的方法只用于学习交流，切勿用于非法途径！！！ 1.下载owasp 2.将owasp添加到VMware中 3.启动owasp4.使用ifconfig查看自己的owasp当前的ip地址，在kali中打开浏览器试的去访问一下该ip是否可以正常使用5.可以正常使用 6.在kali中使用自带的medusa工具去破解owasp的密码注意：在使用medusa之前需要先去生成一个密码字典，来方便我们对其进行破解，密码字典的生成可以使用Crunch工具或John工具。 6.1 输入以下指令开始破解11 medusa -h [目标ip地址] -u [用户名] -P [密码字典] -M [目标使用的协议] 最终破解成功注：该文章中使用到的方法只用于学习交流，切勿用于非法途径！！！","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://codemariosec.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://codemariosec.github.io/tags/kali/"}]},{"title":"使用kali去破解windows主机密码","slug":"使用kali去破解windows主机密码","date":"2022-01-30T18:10:05.000Z","updated":"2022-06-03T06:53:36.783Z","comments":true,"path":"2022/01/31/使用kali去破解windows主机密码/","link":"","permalink":"https://codemariosec.github.io/2022/01/31/%E4%BD%BF%E7%94%A8kali%E5%8E%BB%E7%A0%B4%E8%A7%A3windows%E4%B8%BB%E6%9C%BA%E5%AF%86%E7%A0%81/","excerpt":"通常windows电脑中都设有开机密码，而其系统通常都是默认关闭3389端口的，并且设置了防火墙，以防黑客有机可乘去控制电脑。如果我们需要去破解对方windows的密码，就需要进行以下操作，在这里我们在VMware中使用win7和kali模拟过程。","text":"通常windows电脑中都设有开机密码，而其系统通常都是默认关闭3389端口的，并且设置了防火墙，以防黑客有机可乘去控制电脑。如果我们需要去破解对方windows的密码，就需要进行以下操作，在这里我们在VMware中使用win7和kali模拟过程。 注：该文章中使用到的方法只用于学习交流，切勿用于非法途径！！！1. 开启win7的3389端口（远程桌面端口）3389端口是Windows的远程桌面的服务端口，可以通过这个端口，用”远程桌面”等连接工具来连接到远程的服务器，在连接成功后，输入系统管理员的用户名和密码后，就可以操作远程的电脑，因此远程服务器一般都将这个端口修改数值或者关闭。 1.1 打开控制面板 1.2 点击远程设置 1.3 选择运行任意版本远程桌面的计算机连接（默认是不允许连接到这台计算机） 2. 打开cmd输入Firewall.cpl指令打开防火墙设置 2.1 点击打开或关闭防火墙 2.2 两个选项都选择关闭防火墙 3.在kali中使用自带的nmap工具去扫描win7主机所在ip地址范围内的所有ip地址，查看同网段内的主机的3389端口是开放的3.1 输入以下命令开启扫描1nmap -p 3389 [要扫描的ip地址范围，比如192.168.1.1-255] 3.2 看到主机ip为192.168.178.131的3389端口已启动 4. 使用Crunch或John等工具生成密码字典，为后面使用hydra工具去破解win7密码做准备工作5.使用hydra工具去破解win7所登录账户的密码5.1 输入以下命令去破解1hydra -l [windows的账户名] -P [密码字典] rdp://[win7的ip地址] 最终破解成功注：该文章中使用到的方法只用于学习交流，切勿用于非法途径！！！","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://codemariosec.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://codemariosec.github.io/tags/kali/"}]},{"title":"Web前端_JavaScriptDay10_函数","slug":"Web前端-JavaScriptDay10-函数","date":"2022-01-30T18:09:09.000Z","updated":"2022-06-03T06:53:21.352Z","comments":true,"path":"2022/01/31/Web前端-JavaScriptDay10-函数/","link":"","permalink":"https://codemariosec.github.io/2022/01/31/Web%E5%89%8D%E7%AB%AF-JavaScriptDay10-%E5%87%BD%E6%95%B0/","excerpt":"前言 无论是什么程序设计语言，函数都是重要的一部分内容，在实际开发过程中有很多语法的表达和功能的实现都来源于函数。不过与其它语言不同的是，JavaScript是通过函数来实现面向对象的特性并非通过专门的面向对象语法去实现的，因为JavaScript没有属于自己的专门的面向对象语法，所以函数在JavaScript中更是重中之重。","text":"前言 无论是什么程序设计语言，函数都是重要的一部分内容，在实际开发过程中有很多语法的表达和功能的实现都来源于函数。不过与其它语言不同的是，JavaScript是通过函数来实现面向对象的特性并非通过专门的面向对象语法去实现的，因为JavaScript没有属于自己的专门的面向对象语法，所以函数在JavaScript中更是重中之重。 一、函数的介绍1.什么是函数？ 函数是执行特定任务的代码块，之后通过调用函数实现特定任务功能的实现。 2.函数的组成部分 关键字function。 函数名称。 函数所需要的参数，参数可以是0个，也可以是多个，参数之间要用逗号分隔。 函数执行的代码块，即函数体。 返回值语句return，函数通常都会有返回值，如果某个函数没有显式的返回值，默认返回值为undefined。 12341 function sum(number1,number2) &#123;2 var sum = number1 + number2;3 return sum;4 &#125; 3.如何去调用函数？ 在明白了函数的组成部分后，我们就可以成功创建函数了。不过这只是第一步，在我们创建函数之后要想去使用函数还需去调用函数，因为函数不调用的话是不会执行的。 调用函数的方法是在函数名加传递参数的括号即可。 123456function sum(number1,number2) &#123; var sum = number1 + number2; return sum;&#125;var result = sum(5,4);console.log(result); //9 4.关于函数中的参数 定义函数的时候我们可能会设置函数所需要的调用参数，这个参数的设定不是必须的，可以选择不设定。如果设定了调用参数，在调用函数的时候就必须要传递相关的参数值，程序才能正常执行。如果没有传递相关的参数值，未被传递参数值的地方就会默认为undefined。 12345678910111213//函数中设置了调用参数但是在调用函数的过程中并未去传递相关参数值导致的结果。function sum1(number) &#123; return number;&#125;var result1 = sum1();console.log(result1); //undefined//函数中漏传参数导致参数+undefined得到NaN。function sum2(number1,number2) &#123; return number1 + number2;&#125;var result2 = sum2(1);console.log(result2); //NaN 参数分为形式参数和实际参数两种，其中形式参数是指定义函数时所用到的参数，实际参数是指在调用函数时所传递的参数。 123456function sum(number1,number2) &#123; var sum = number1 + number2; return sum;&#125;var result = sum(5,4,3,2,1); //JavaScript只会解析5和4这两个值，最后输出结果9，其它会被忽略console.log(result); 不过我们可以使用arguments变量在函数中去调用并返回接受的所有参数，arguments变量是内建变量，在每个函数中都能调用。 123456function args() &#123; return arguments;&#125;var result = args(5,4,3,2,1,true,&quot;A&quot;,&#x27;b&#x27;);//Arguments(8) [5, 4, 3, 2, 1, true, &quot;A&quot;, &quot;b&quot;, callee: ƒ,Symbol(Symbol.iterator): ƒ]console.log(result); 通过arguments可以对参数进行求和运算。 123456789function sum() &#123; var result = 0; for(var i = 0 ; i &lt; arguments.length ; i++) &#123; result += arguments[i]; &#125; return result;&#125;var res = sum(5,4,3,2,1);console.log(res); //15 二、parseInt() parseInt()会将接收到任何输入值转换为整数类型输出，通常都是输入字符串，转换失败则返回NaN。 123456789101112 1 var a = parseInt(&quot;5a7b6&quot;); 2 console.log(a); //5 3 var b = parseInt(&quot;1024&quot;); 4 console.log(b); //1024 5 var c = parseInt(&quot;abc1024&quot;); 6 console.log(c); //NaN 7 var d = parseInt(&quot;3.14&quot;); 8 console.log(d); //3 9 var e = parseInt(&quot;0124&quot;);10 console.log(e); //12411 var f = parseInt(&quot;0x1024&quot;);12 console.log(f); //4132 parseInt(string,radix)中可以传两个值，第一个值可以解析的是字符串，第二个值解析的是数字的基数，即设定函数所要被解析的数据类型，其中可以传递的进制值范围在2~36之间，如果以”0x”开头第二参数则默认指定为16进制数。 121 var a = parseInt(&quot;0x1024&quot;);2 console.log(a); //4132 注意：在这个函数的应用过程中我们会发现一个很有趣的现象，如果以“0x”开头的数字第二参数默认指定为16进制数，那么按道理以“0”开头的数字第二参数应该会被默认指定为8进制数，但是在现实中并不是这样的。如果我们使用parseInt()函数反而得不到这个结果，以“0”开头的数字最终会忽略0而被解析0后面的数字为10进制的数值。因为ECMAScript5移除了8进制的默认表示法，这种做法是避免了在8进制解析和10进制解析时候的混淆。 121 var a = parseInt(&quot;0124&quot;);2 console.log(a); //124 三、parseFloat() 上面我们学习了parseInt()的使用，parseFloat()的使用与parseInt()是基本相同的，区别在于parseFloat()只能将输入值转换为十进制数，所以这个函数只能传入一个参数。而且parseFloat()解析的字符串返回的是一个浮点数。 123456781 var a = parseFloat(&quot;3.14a&quot;);2 console.log(a); //3.143 var b = parseFloat(&quot;3.14&quot;);4 console.log(b); //3.145 var c = parseFloat(&quot;1.230800&quot;);6 console.log(c); //1.23087 var d = parseFloat(&quot;ab12c&quot;);8 console.log(d); //NaN parseFloat()可以接受指数形式的数据。 12341 var a = parseFloat(&quot;123e-2&quot;);2 console.log(a); //1.233 var b = parseFloat(&quot;1e5&quot;);4 console.log(b); //100000 四、isNaN() 使用isNaN()函数可用于检查参数是否是非数字值。 123456781 console.log(isNaN(1024)); //false2 console.log(isNaN(-1024)); //false3 console.log(isNaN(1.024)); //false4 console.log(isNaN(-1.024)); //false5 console.log(isNaN(2024-2)); //false6 console.log(isNaN(0)); //false7 console.log(isNaN(&quot;JavaScript&quot;)); //true8 console.log(isNaN(&quot;2021/01/01&quot;)); //true 使用isNaN()函数可以检测parseInt()和parseFloat()是否成功调用。 12345678910 1 var a = isNaN(parseInt(&quot;0x1024&quot;)); 2 console.log(a); //false 3 var b = isNaN(parseFloat(&quot;1.1&quot;)); 4 console.log(b); //false 5 var c = isNaN(parseInt(&quot;1.2&quot;)); 6 console.log(c); //false 7 var d = isNaN(parseInt(&quot;ac1024&quot;)); 8 console.log(d); //true 9 var e = isNaN(parseFloat(&quot;ac1024&quot;));10 console.log(e); //true 值得一提的是，NaN自己不存在等值的概念，所以NaN &#x3D;&#x3D; NaN返回的是false。 五、isFinite() isFinite()可以检查输入的是否是一个非Infifnity非NaN的数字。 12345671 console.log(isFinite(Infinity)); //false2 console.log(isFinite(-Infinity)); //false3 console.log(isFinite(1024)); //true4 console.log(isFinite(1e308)); //true5 console.log(isFinite(-1e308)); //true6 console.log(isFinite(1e309)); //false7 console.log(isFinite(-1e309)); //false 六、eval() eval()函数会将输入的字符串当做JavaScript代码执行。 12eval(&#x27;var a = 1;&#x27;);console.log(a); //1 七、变量的作用域 在JavaScript中，变量的作用域是以函数作为作用域的，即变量如果是在某个函数定义的，该变量在函数以外的地方是不可见的。如果该变量是定义在if或者for这样的代码块中，它在代码块之外是可见的。定义在所有函数之外的变量是全局变量，定义在函数中的变量是局部变量。 1234567891011 1 var number1 = 1; 2 function f() &#123; 3 var number2 = 4; 4 number1++; 5 console.log(number2); //4 6 return number1; 7 &#125; 8 console.log(number1); //1 9 var result = f();10 console.log(result); //211 console.log(number2); //Uncaught ReferenceError: number2 is not defined 由以上示例可以看出函数f()可以访问number1，number1是全局变量，而在函数体外number2无法被访问，因为number2是局部变量，局部变量只能在本函数中被访问。 但是，在JavaScript中总有一些令人比较惊讶的现象。如果在声明变量的时候没有去使用关键字变量去定义相关变量的话，该变量会被默认为全局变量。 1234561 var number1 = 1;2 function f() &#123;3 number2 = 2;4 &#125;5 f();6 console.log(number2); //2 八、匿名函数 没有名字的函数被称为匿名函数。 1234561 var a = function() &#123;2 return 2;3 &#125;4 var b = function(x) &#123;5 return x;6 &#125; 形如以上的示例就是匿名函数。当匿名函数不被赋值给变量去单独使用的时候，这类函数有两种用法： 可以将匿名函数作为参数传递给其它函数，这样接收方函数可以利用传递的函数完成某些事情。 可以去定义某个匿名函数执行某些一次性任务。 在后面的内容中我们会用到这些用法。 九、回调函数1.回调函数与匿名回调函数 函数A传递给函数B，函数B来执行函数A的时候，A就是一个回调函数。 1234567891 function sum(a) &#123;2 return a();3 &#125;4 var result = sum( 5 function() &#123;6 return 1;7 &#125;8 ); 9 console.log(result); //1 也可以使用回调函数进行进行加法运算。 12345678910111213141516 1 function sum(a,b,c) &#123; 2 return a() + b() + c(); 3 &#125; 4 var result = sum( 5 6 function() &#123; 7 return 1; 8 &#125;, 9 function() &#123;10 return 2.5;11 &#125;,12 function() &#123;13 return 3;14 &#125;15 ); 16 console.log(result); //6.5 我们看到这两个示例中在调用sum的时候都是使用了匿名函数，而且这些匿名函数也是一个回调函数，这样的函数我们称之为匿名回调函数。 2.什么情况下使用回调函数？ 在未命名的情况下去传递函数，从而节省变量名的使用。 将一个函数调用给另一个函数去执行，可以节省一些代码编写工作。 在数据量很大的情况下使用回调函数是一个好的选择。 12345678910111213 1 function sum(a,b,c,returnValue) &#123; 2 var array = []; 3 for(var i = 0;i &lt; 3;i++) &#123; 4 array[i] = returnValue(arguments[i] * 2); 5 &#125; 6 return array; 7 &#125; 8 9 var result = sum(1,2,3,function(a) &#123;10 return a + 1;11 &#125;);12 13 console.log(result); //[3, 5, 7] 十、即时函数 可以在被定义后立即调用的函数是即时函数。 123451 (2 function() &#123;3 console.log(&#x27;JavaScript&#x27;); //JavaScript4 &#125;5 )(); 括号也可以放在第二对括号之后。 123451 (2 function(message) &#123;3 console.log(&#x27;Hello &#x27; + message); //Hello JavaScript4 &#125;5 (&#x27;JavaScript&#x27;)); 使用匿名函数的好处是不会产生任何全局变量。缺点是在于这样的函数是无法重复执行的，这也使即时函数非常适合于去执行一些一次性的或初始化的任务。 十一、内部函数1.什么是内部函数？ 在一个函数内部定义另一个函数，内部定义的函数就被称为内部函数，内部函数也叫做私有函数，只能在内部去访问。 1234567891 function outer(param) &#123;2 3 function inner(theinput) &#123;4 return theinput * 2;5 &#125;6 return &#x27;The result is &#x27; + inner(param);7 &#125;8 9 console.log(outer(2)); //The result is 4 2.私有函数的特点 确保全局名字空间的唯一性，以免命名冲突。 确保一些函数的私有性，做到只将一部分必要的函数暴露在外，具有一定的安全性。 十二、返回函数的函数 返回函数的函数听起来有些奇怪，不过细细想一想的话就是在一个函数中的返回值也是一个函数，这就是返回函数的函数。 123456789101112 1 function a() &#123; 2 console.log(&quot;Hello&quot;); 3 return function() &#123; 4 console.log(&quot;JavaScript&quot;); 5 &#125; 6 &#125; 7 var result = a(); //Hello 8 result(); //JavaScript 9 10 //也可以这样去输出，结果是相同的11 //a()(); //Hello12 //JavaScript 十三、函数可以被重写 还是上面的例子，我们可以使用新的函数去覆盖旧的函数，我们在函数内部去重写函数覆盖外部的函数。 123456781 function a() &#123;2 alert(&quot;Hello&quot;);3 b = function() &#123;4 alert(&quot;JavaScript&quot;);5 &#125;6 &#125;7 a(); //Hello8 b(); //JavaScript 十四、闭包 在看闭包之前先看一个示例： 123456789101112 1 function sum(number) &#123; 2 var all = 0; 3 return all += number; 4 &#125; 5 6 console.log(sum(1)); //1 7 console.log(sum(1)); //1 8 console.log(sum(1)); //1 9 console.log(sum(1)); //110 console.log(sum(2)); //211 console.log(sum(2)); //212 console.log(sum(3)); //3 上面的示例中我们如果不改变传入函数的数值无论是调用多少次最终的结果就不会被改变，在某些应用场景下这是极其不方便的，这时候就引入了闭包。在使用闭包的时候，我们可以在反复调用的过程中去不停的进行值的改变。在实际中我们可以以日常多开网站去举例。 我们日常可能会多开好几个网站，每个网站我们可能会在同一个浏览器上打开好几个，在我们打开同一个浏览器好几个页面的时候会占用内存空间，几个页面运行的过程中可以看做是反复调用函数，这个过程中我们在同一个浏览器去打开多个页面的时候每次打开的页面都和我们上次打开的页面不同，这个过程细化过来我们可以将其看做是闭包，是调用函数且还占用内存去执行并变化的过程，变量会一直保留在内存中，所以我们在最小化浏览器页面后浏览器并未被关闭，内存依然会被占用。 12345678910111213 1 function sum(number) &#123; 2 var all = 0; 3 return function() &#123; 4 all += 1; 5 return all; 6 &#125; 7 &#125; 8 9 var storage = sum();10 console.log(storage()); //111 console.log(storage()); //212 console.log(storage()); //313 console.log(storage()); //4 从上面的示例可以明白闭包是创建一个函数，用一些变量包装起来，之后再保存起来去使用，而函数保留对其作用域访问的过程我们就称之为闭包。 当然，每次在定义函数的时候都会为函数创建闭包，所以我们可以说每个函数都有闭包。但是，只有我们在使用嵌套函数的时候闭包的功能才能真正发挥出来。 12345678910 1 var number = 1; 2 function sum1() &#123; 3 var number = 4; //覆盖了上面的number 4 5 function sum2() &#123; 6 console.log(&quot;这个数字为：&quot; + number); //sum2()函数和其中的语法形成了一个闭包，引用的sum1()中局部声明的number变量。 7 &#125; 8 return sum2(); 9 &#125;10 sum1(); //这个数字为：4","categories":[{"name":"前端","slug":"前端","permalink":"https://codemariosec.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codemariosec.github.io/tags/JavaScript/"}]},{"title":"Web前端_JavaScript的Day2_基本数据类型、数组、循环及条件表达式","slug":"Web前端-JavaScript的Day2-基本数据类型、数组、循环及条件表达式","date":"2022-01-30T17:55:17.000Z","updated":"2022-06-03T06:53:12.966Z","comments":true,"path":"2022/01/31/Web前端-JavaScript的Day2-基本数据类型、数组、循环及条件表达式/","link":"","permalink":"https://codemariosec.github.io/2022/01/31/Web%E5%89%8D%E7%AB%AF-JavaScript%E7%9A%84Day2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"前言这部分内容主要介绍了JavaScript中基本数据类型、数组的基础知识、循环的常规应用以及表达式。","text":"前言这部分内容主要介绍了JavaScript中基本数据类型、数组的基础知识、循环的常规应用以及表达式。 变量1.什么是变量？变量是用来存储数据的，是存放具体数值的容器。 2.变量的命名规范变量名可以由字母、数字、下划线及美元符号组成，但是不能以数字开头。 3.变量的使用 先声明变量后初始化变量。 可以声明变量同时并初始化变量。 注意：变量名是区分大小写的。 操作符1.什么是变量？变量是用来存储数据的，是存放具体数值的容器。 2.基本的算术运算符变量是用来存储数据的，是存放具体数值的容器。 操作符 相关操作 代码示例 + 加法操作 1 + 2 - 减法操作 2 - 1 * 乘法操作 1 * 2 &#x2F; 除法操作 2 &#x2F; 1 % 取模操作 2 % 2 ++ 自增1运算 前置++操作先自增加1再返回加过后的值var a &#x3D; 1;var b &#x3D; ++a;b &#x3D; 2a &#x3D; 2后置++操作先返回原来的值再自增加1var a &#x3D; 1;var b &#x3D; a++;b &#x3D; 1 a &#x3D; 2 – 自减1运算 前置–操作先自减减1再返回加过后的值var a &#x3D; 2;var b &#x3D; –a;b &#x3D; 1a &#x3D; 1后置–操作先返回原来的值再自减减1var a &#x3D; 2;var b &#x3D; a–;b &#x3D; 2a &#x3D; 1 3.复合操作运算符 操作符 代码示例 代码变形 +&#x3D; var a &#x3D; 1;a +&#x3D; 1;console.log(a); a &#x3D; 2 var a &#x3D; 1;a &#x3D; a + 1;console.log(a);a &#x3D; 2 -&#x3D; var a &#x3D; 1;a -&#x3D; 1;console.log(a);a &#x3D; 0 var a &#x3D; 1;a &#x3D; a - 1;console.log(a);a &#x3D; 0 *&#x3D; var a &#x3D; 1;a *&#x3D; 2;console.log(a);a &#x3D; 2 var a &#x3D; 1;a &#x3D; a * 2;console.log(a);a &#x3D; 2 &#x2F;&#x3D; var a &#x3D; 2;a &#x2F;&#x3D; 2;console.log(a);a &#x3D; 1 var a &#x3D; 2;a &#x3D; a &#x2F; 2;console.log(a);a &#x3D; 1 %&#x3D; var a &#x3D; 2;a %&#x3D; 2;console.log(a);a &#x3D; 0 var a &#x3D; 2;a &#x3D; a % 2;console.log(a);a &#x3D; 0 操作符JavaScript中包含以下几大基本数据类型： 数字型——包括整数和浮点数，例如：1、1.1、3.14。字符串型——包括由任意字符组成的序列，例如：“a”、“one 2 two”。布尔型——只有两种形式，true和false。undefined——没有值的变量，当我们去访问这种并不存在的变量时，会得到这个特殊值undefined。null——表示没有值或空值。在JavaScript中，null的数据类型是对象。 1.typeof操作符使用typeof我们能够知道返回某个变量或值的类型是什么，该操作符的返回结果可能是： 123456781 console.log(typeof null); //Object2 console.log(typeof 10); //number3 console.log(typeof &quot;a&quot;); //string4 console.log(typeof &#x27;10&#x27;); //string5 console.log(typeof true); //boolean6 console.log(typeof function()&#123;&#125;); //function7 console.log(typeof a); //undefined8 console.log(typeof undefined); //undefined 所以在JavaScript中使用typeof操作符返回的结果是： “number”; “string”; “boolean”; “undefined”; “object”; “function” 注意： 当八进制和十六进制的数字使用typeof操作符时返回的结果是number类型。 121 console.log(typeof 0377); //八进制返回&quot;number&quot;2 console.log(typeof 0xff); //十六进制返回&quot;number&quot; 当使用指数去表示的时候返回的是number类型 1231 //2e1和2e+1是指数的两种表示方法2 console.log(typeof 2e1); //number3 console.log(typeof 2e+1); //number 使用typeof操作符返回Infinity和-Infinity的结果也是number 121 console.log(typeof Infinity); //number2 console.log(typeof -Infinity); //number 使用typeof操作符返回NaN的结果也是number 11 console.log(typeof NaN); 2.数字型1.Infinity在JavaScript中，超出处理范围的数值用Infinity这个特殊值来表示。例如当我们向控制台输出1e308时，返回结果正常，而向控制台再输出1e309的时候就超出范围了，所以会返回Infinity，其中如果超出最大值就是返回Infinity，如果超出最小值就返回-infinity。 1231 console.log(1e308); //1e+3082 console.log(1e309); //Infinity3 console.log(-1e309); //-Infinity Infinity和-Infinity相加得到的不是0而是NaN，Infinity-Infinity得到的也是NaN而并非0,实际上二者都一样。 121 console.log(-Infinity + Infinity); //NaN2 console.log(Infinity - Infinity); //NaN Infinity和数字执行除了取模以外的运算得到的结果都是Infinity，取模运算得到的是NaN。 123451 console.log(Infinity + 10); //Infinity2 console.log(Infinity - 10); //Infinity3 console.log(Infinity * 10); //Infinity4 console.log(Infinity / 10); //Infinity5 console.log(Infinity % 10); //NaN 2.NaN虽然NaN代表的是不是数字，但是正如我们在上面typeof中使用typeof操作符的时候一样，返回的值的类型也是数字类型，所以NaN是一种特殊的数字。 注意： 如果我们计算1 + “a”得到的结果是1a这个拼接后的字符串，但是如果我们使用的是其它的几个算术运算符的话返回的结果是NaN，因为这是错误的运算方式，返回的结果不会是一个数字。 如果我们在算术运算中将NaN算进去的话，整个运算得到的结果也是NaN。 1234561 console.log(1 + &quot;a&quot;); //1a2 console.log(1 - &quot;a&quot;); //NaN3 console.log(1 * &quot;a&quot;); //NaN4 console.log(1 / &quot;a&quot;); //NaN5 console.log(1 % &quot;a&quot;); //NaN6 console.log(1 + 2 + NaN + 3); //NaN 3.字符串型字符串通常表示的是某段表示文本的字符序列。和某些语言不同的是，JavaScript语言中一对单引号或双引号之间的任何值都是一个字符串，有些编程语言单引号只能是表示字符，双引号表示字符串。所以在JavaScript中，’1’和”1”表示的都是字符串。字符串使用typeof操作符会返回string这个结果。 1.字符串的表示 在JavaScript中字符串可以用单引号表示也可以用双引号表示。 字符串可以是引号中的零个或多个字符。 字符串可以是带单引号或双引号的任何值。 字符串之间可以使用加号运算符进行拼接，拼接后得到的新的字符串依然是字符串类型。 2.字符串类型和其它类型之间的相互转换布尔型转字符串型通过a布尔类型与字符串使用加号运算符拼接将a由布尔类型转换为字符串类型。 123451 var a = true;2 var b = &quot;&quot;;3 var c = a + b;4 console.log(c); //true5 console.log(typeof c); //string 字符串型转数字型通过字符串类型和数字类型使用乘号运算符拼接得到的是数字类型。 123451 var a = &quot;&quot;;2 var b = 1;3 var c = a * b;4 console.log(c); //15 console.log(typeof c); //number 通过Number()方法返回数字，将字符串类型值转换为数字类型值。 1231 var a = Number(&quot;2021&quot;) + 1;2 console.log(a); //20223 console.log(typeof a); //number 通过parseInt()方法解析一段字符串并返回数值。 1231 var a = parseInt(&quot;5a7b6&quot;);2 console.log(a); //53 console.log(typeof a); //number 注意：parseInt()方法允许空格且只返回首个数字，上面的示例开头数字是5，所以最后返回的数值结果就是5。 1231 var a = parseInt(&quot;1024&quot;);2 console.log(a); //10243 console.log(typeof a); //number 所以说如果parseInt()方法中解析的字符串首字母不是数字的话返回的值就是NaN。 1231 var a = parseInt(&quot;3.14&quot;);2 console.log(a); //33 console.log(typeof a); //number 通过parseFloat()方法解析一段字符串并返回数值。 1231 var a = parseFloat(&quot;3.14a&quot;);2 console.log(a); //3.143 console.log(typeof a); //number 注意：parseFloat()方法允许空格且只返回首个数字，上面的示例开头数字是3.14，所以最后返回的数值结果就是3.14。 1231 var a = parseFloat(&quot;3.14&quot;);2 console.log(a); //3.143 console.log(typeof a); //number 所以说如果parseFloat()方法中解析的字符串首字母不是数字的话返回的值就是NaN。 1231 var a = parseFloat(&quot;ab12c&quot;);2 console.log(a); //NaN3 console.log(typeof a); //number 数字型转字符串型通过字符串类型和数字类型进行拼接将数字类型的值转换为字符串类型值。 123451 var a = &#x27;&#x27;;2 var b = 1;3 var c = a + b;4 console.log(c); //15 console.log(typeof c); //string 3.字符串拼接字符串与字符串拼接得到的结果还是字符串类型。 123451 var a = &#x27;java&#x27;;2 var b = &quot;script&quot;;3 var c = a + b;4 console.log(c); //javascript5 console.log(typeof c); //string 4.常用特殊字符串 字符串 含义 示例 \\ &#39; &#39;‘ \\是转义字符，当我们 想要在字符串中去使用 引号的时候需要用到 这个字符，使用这个字 符对引号进行转义最终 输出的结果才是正常的结 果，否则JavaScript 可能会将相同的引号匹 配错误从而造成值的截断。 当然，我们在字符串中 使用\\本身的时候也需要使用另一个\\将\\本 身进行转义，否则JavaScript 会认为\\本体是一个转义字符。 var a &#x3D; ‘I don’t konw’;以上的做法是错误的，因为JavaScript会将”I don’t”视为字符串，而其余部分则是无效代码，从而截断了后面的部分，我们应该是这样去做： var a &#x3D; ‘I don&#39;t know’;var a &#x3D; “I don’t know”;var a &#x3D; ‘“Hello”,World’;var a &#x3D; “&quot;Hello&quot;,World”; \\n 换行符 var a &#x3D; ‘\\n1\\n2\\n3\\n’;console.log(a);123 \\r 回车符 var a &#x3D; ‘1\\r\\n2’;console.log(a);”12” \\t 制表符 var a &#x3D; “1\\t2”;console.log(a);”12” \\u \\u后面的字符会被视为Unicode码 下面是作者的名字在保加利亚语中用西里尔字母的拼写：”\\u0421\\u0442\\u043E\\u044F\\u043D”; “”Стoян”” 4.布尔型布尔类型只有true和false两种值，一般作为判断语句去使用。 布尔类型在使用typeof操作符的时候返回的值类型是boolean类型。 在JavaScript中有三种布尔运算的运算符，分别是： !——逻辑非（取反）； &amp;&amp;——逻辑与； ||——逻辑或； 其中，逻辑非代表事物不是真的状态，逻辑与是代表当前事物和操作中所有的一切都是真最终结果才为真，只要有一个不满足就为假，即使是另外的条件满足。逻辑或则是多个条件中其中一个条件满足就为真，只有都为假的时候才能为假。 以下表列出相应情况 操作 结果 true &amp;&amp; true true true &amp;&amp; false false false &amp;&amp; true false false &amp;&amp; false false true || true true true || false true false || true true false || false false 注意：在或、与、非三个布尔运算符之中优先级为!（非）&gt;&amp;&amp;（或）&gt;||（与）。当然，在JavaScript中，还有另一组以布尔值为返回值类型的操作符，我们称之为比较运算符。 操作符 操作说明 代码示例 &#x3D;&#x3D; 相等运算符，即当两个 操作数相等时返回true， 比较的时候运算符两边 的数值会被自动转换为相同的类型。 console.log(1 &#x3D;&#x3D; 1);trueconsole.log(1 &#x3D;&#x3D; 2);falseconsole.log(1 &#x3D;&#x3D; ‘1’);true &#x3D;&#x3D;&#x3D; 严格相等运算符，当两边 的操作数的值和类型都 相同的时候才返回true， 可以说是全等于这类型的。这是一种比较全面可靠的 比较，因为这样的比较 不会出现可能发生的某个操作数 类型转换再比较。 console.log(1 &#x3D;&#x3D;&#x3D; 1);trueconsole.log(1 &#x3D;&#x3D;&#x3D; ‘1’);false !&#x3D; 不相等运算符，当两边 的操作数不相等的时候 返回true，这种比较是会进行类型转换为 相同类型进行比较。 console.log(1 !&#x3D; 1);falseconsole.log(1 !&#x3D; ‘1’);falseconsole.log(1 !&#x3D; ‘2’);true !&#x3D;&#x3D; 严格不相等运算符，当两边 的操作数的值和类型都不相同 的时候才返回true， 可以说是全不等于这类型的。这是一种比较全面可靠的比较， 因为这样的比较不会出现可能发生的某个操作数 类型转换再比较。 console.log(1 !&#x3D;&#x3D; 1);falseconsole.log(1 !&#x3D;&#x3D; ‘1’);true &gt; 当符号左边的数大于右边的数的时候返回true。 1 &gt; 1;false2 &gt; 1;true &gt;&#x3D; 当符号左边的数大于等于右边的数的时候返回true。 1 &gt;&#x3D; 1;true1&gt;&#x3D; 2;false &lt; 当符号左边的数小于右边的数的时候返回true。 1 &lt; 1;false1 &lt; 2;true &lt;&#x3D; 当符号左边的数小于等于右边的数的时候返回true。 1 &lt;&#x3D; 1;true2 &lt;&#x3D; 1;false 注意：NaN不等于任何东西，哪怕是自己，例如NaN &#x3D;&#x3D; NaN;返回值也为false。 数组1.什么是数组？数组是一个用于存储数据的列表，这个列表可以存放任意数量的元素值。示例： 121 var a = [1,2,3];2 console.log(a); //[1,2,3] 记住，元素在数组中的索引位置下标是从0开始的，所以数组元素的首个索引值是0，第二个元素索引值是1，以此类推。 12341 var a = [1,2,3];2 console.log(a[0]); //13 console.log(a[1]); //24 console.log(a[2]); //3 2.数组的特点 数组是一种数据存储形式。 数组是可以被索引的。 数组中的元素索引值是从0开始，按照每个元素的位置去依次递增。 数组能存储任何类型的数据，包括另一个数组。 我们可以对数组进行增删改查。 我们可以通过数组访问的方式去获取字符串中特定位置上的字符。 3.关于数组元素的增加和更新我们可以通过索引去直接增加或者更新数组中的元素，例如： 123451 var a = [1,2,3];2 a[1] = &quot;two&quot;; //修改元素索引值为1的数3 a[3] = &quot;four&quot;; //增加元素索引值为3的地方4 a[5] = &quot;six&quot;; //增加元素索引值为6的地方，索引值为5的地方在控制台上输出的时候是空值5 console.log(a); //[1, &quot;two&quot;, 3, &quot;four&quot;, empty, &quot;six&quot;] 4.关于数组元素的删除删除数组中特定的元素我们需要使用delete操作符去实现操作。 1231 var a = [1,2,3];2 delete a[1];3 console.log(a); // [1, empty, 3] 5.利用数组访问字符串我们可以通过数组访问的方式去获取字符串中特定位置上的字符。 12341 var a = &#x27;abc&#x27;;2 console.log(a[0]); //a3 console.log(a[1]); //b4 console.log(a[2]); //c 条件与循环条件与循环是实际开发过程中重要的一部分，通过使用条件我们可以控制一段代码的执行走向，通过循环我们可以重复去执行某段代码。 1.if条件表达式if条件表达式主要由if语句、语句条件、执行的代码块以及代码块内部的执行语句组成。其中语句条件是指逻辑类或者是比较类并返回布尔值类型的操作语句组成。 2.else语句else语句是if语句的可选项，运用于if语句表达式条件返回值为false的时候去执行该部分所包含的语句。 举个栗子： 1234561 var a = 2;2 if(a &gt; 2) &#123;3 console.log(&quot;a是一个大于2的数字&quot;);4 &#125; else &#123;5 console.log(&quot;a不是大于2的数字&quot;);6 &#125; 此外我们还有else if语句，也是if语句的可选项，是分支判断语句，例如： 123456781 var a = 2;2 if(a == 1) &#123;3 console.log(&quot;a = 1&quot;);4 &#125; else if(a == 2) &#123;5 console.log(&quot;a = 2&quot;);6 &#125; else &#123;7 console.log(&quot;a不满足上述条件&quot;);8 &#125; 3.switch语句当if语句中出现过多的else if语句的时候，最好使用switch语句进行条件的判断。 123456789101112131415 1 var a = 1; 2 var result = &#x27;&#x27;; 3 switch(a) &#123; 4 case 1: 5 result = &#x27;Number 1&#x27;; 6 break; 7 case 2: 8 result = &#x27;Number 2&#x27;; 9 break;10 default:11 result = &#x27;Number X&#x27;;12 break;13 &#125;14 console.log(result);15 //输出结果：Number 1 switch语句的组成部分及其作用 switch子句。 括号表达式。表达式通常是一个变量，有时候也可以是其它能够提供返回值的东西。 包含在switch语句大括号中的case序列块。 每个case语句下的表达式，如果表达式结果与switch语句表达式对比结果为true则case语句冒号之后的代码会被执行。 break语句是可选的，当代码执行到break语句时，就跳出当前循环结束整个过程的执行。 default关键字是默认条件代码块，当case条件的语句都不为true的时候，就执行default条件里的语句。 4.循环通过循环语句我们可以使某段代码可以反复执行，便于操作。 在JavaScript中，循环分为四种类型： while循环； do-while循环； for循环； for-in循环。 1.while循环while循环语句分为小括号中的条件和大括号中的代码块,当小括号中的条件为true的时候会执行。 123451 var a = 0;2 while(a &lt; 10) &#123;3 a++;4 &#125;5 console.log(a); 2.do-while循环do-while循环和while循环没有多大的区别，只不过是do-while循环里的代码块会至少执行一次，先执行，后判断。 123451 var a = 0;2 do &#123;3 a++;4 &#125; while(a &lt; 10);5 console.log(a); 3.for循环for循环主要包括以下内容： 初始化部分定义一个循环变量，例如var i &#x3D; 0; 条件部分将i与循环边界值进行对比。例如i &lt; 10; 自增部分将循环变量i自增1，例如i++。 举个栗子： 123451 var a = &#x27;&#x27;;2 for(var i = 0;i &lt; 10;i++) &#123;3 a = &#x27;Hello World&#x27;;4 &#125;5 console.log(&quot;输出&quot; + a); 可以这样去表示： 12341 for(var i = 0,a = &#x27;&#x27;;i &lt; 10;i++) &#123;2 a = &#x27;Hello World&#x27;;3 &#125;4 console.log(&quot;输出&quot; + a); 不过这样写的话可读性会变得很差，所以并不建议这样写。for循环彼此之间可以进行嵌套。 123451 for(var i = 0;i &lt; 10;i++) &#123;2 for(var j = 0;j &lt; 10;j++) &#123;3 4 &#125;5 &#125; 4.for-in循环for-in循环往往被用来遍历某个数组中的元素。 示例： 1234561 var a = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;];2 var result = &#x27;\\n&#x27;;3 for(var i in a) &#123;4 result = &#x27;index:&#x27; + i +&#x27;,value:&#x27; + a[i] + &#x27;\\n&#x27;;5 console.log(result);6 &#125; 总结这部分内容主要介绍了JavaScript中的基本数据类型、数组、循环以及条件表达式的常规应用，尤其在数组方面并没有介绍全面，在后面的学习中再学到更多的应用时再做补充。","categories":[{"name":"前端","slug":"前端","permalink":"https://codemariosec.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codemariosec.github.io/tags/JavaScript/"}]},{"title":"Web前端_JavaScript的Day1_面向对象的初步理解","slug":"Web前端-JavaScript的Day1-面向对象的初步理解","date":"2022-01-30T17:24:26.000Z","updated":"2022-06-03T06:53:03.646Z","comments":true,"path":"2022/01/31/Web前端-JavaScript的Day1-面向对象的初步理解/","link":"","permalink":"https://codemariosec.github.io/2022/01/31/Web%E5%89%8D%E7%AB%AF-JavaScript%E7%9A%84Day1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/","excerpt":"前言JavaScript是一门面向对象的解释型脚本语言，通过利用面向对象的这种特性，实现了代码重用，并构建起了可伸缩的代码框架。作为JavaScript的初学者，因为面向对象是JavaScript的核心部分，所以在开始就略微的去学习了JavaScript的面向对象的基础概念部分，能够对于JavaScript的面向对象积累一些初始概念，并将自己对这些的感悟分享出来与大家交流。 作为初学者，可能有些地方理解不够正确，希望大家能提出自己的见解，欢迎批评指正。","text":"前言JavaScript是一门面向对象的解释型脚本语言，通过利用面向对象的这种特性，实现了代码重用，并构建起了可伸缩的代码框架。作为JavaScript的初学者，因为面向对象是JavaScript的核心部分，所以在开始就略微的去学习了JavaScript的面向对象的基础概念部分，能够对于JavaScript的面向对象积累一些初始概念，并将自己对这些的感悟分享出来与大家交流。 作为初学者，可能有些地方理解不够正确，希望大家能提出自己的见解，欢迎批评指正。 面向对象程序设计最常用到的概念面向对象程序设计最常用到的概念如下： 对象、方法、属性； 类； 封装； 聚合; 重用与继承； 多态。 1.对象JavaScript是面向对象的解释型脚本语言，所以面向对象是该编程语言的核心所在。那么什么是对象？对象我们有时候也叫“实例”，实际上就是指事物在程序语言中的表现形式，这类事物可以是人也可以是物，可以是客观存在的具体化对象，也可以是抽象的概念对象。这类事物往往具有其特定的称呼和特征，以及行为等。 例如：有一只黑色的猫在床上睡觉。其中，猫代表的是对象，黑色是颜色，代表属性，睡觉是一种动作行为，代表方法，在床上是睡觉的限定条件，限定动作的条件，也可以看做是传递给睡觉这个方法的参数。 2.类 我们知道在现实生活中，相似对象之间往往具有一些共同的组成特征。比如阿拉斯加犬和哈士奇都属于狗类并具有狗类的特征，因此它们属于同一个类。所以类实际上就是一群具有相同特征的对象并同属一个类组成的集合。阿拉斯加犬是一个实例化对象，哈士奇是一个实例化对象，它们都是由同一个类创造出来的，而这个类还可以创造出其它具有相同特征的实例化对象，所以类也可以当做是一种模板，对象就是在模板上创建出来的实体。 当然，JavaScript并不存在类这一说法，它的一切都是基于对象，依靠着一套原型系统。在传统的面向对象语言中我们可以这样描述：我基于Cat类创建了一个叫做BlackCat的对象，而在基于原型的面向对象的语言中则是这样说道：我将现有的Cat对象扩展成一个叫做BlackCat的对象。 3.封装 封装是用来封装对象中的内容，因此封装实际上就是去阐述对象中包含的内容。这些内容可以是属性，也可以是方法。 例如：一部手机是一个对象，手机里的处理器、电池、电路板等部件就是属性，我们作为用户通常通过手机的按钮、显示屏一类的接口去使用对应的方法，这等价于OOP(面向对象的程序设计)中的调用方法。但是这些接口的实现过程和手机所具有的属性等都是不可见的，我们并不清楚它们内部是如何工作的，只需要通过接口去使用功能即可。在编译类型的语言中我们也是直接去调用方法实现相应的功能即可，而不是去关心它的实现过程。 能够达到以上事例中的内容的封闭性就是封装。而封装的意义就是方便用户操作，优化用户体验。 在某些编程语言中我们可以使用public、private、project、default这些关键字来限定方法和属性的可见性，通过限定分类定义了用户所能访问的层次。但是在JavaScript中，所有的方法和属性都是public，话是这样说，其实JavaScript中也是提供了一些隐藏数据的方法来保护程序的隐私性。 4.聚合 聚合也被称为组合，就是将几个现有对象合并为一个新对象的过程。这个过程实际上是一种思想，在实际解决问题的过程中我们可以采用这种思想将一个问题分解成多个小的问题，这些多个小的问题相对而言更加容易思考，提高解决问题的效率。 例如：在图书管理系统中我们要找《JavaScript高级程序设计》这本书，假若我们不使用检索功能去直接搜寻书，从一个系统包含的成千上万本书中去查找一本书也是一个很费劲的工作。因此我们可以将图书管理系统的功能模块细化，分门别类并有选择有目的的去寻找。《JavaScript高级程序设计》是一本关于前端的书籍，而前端书籍是属于技术类书籍，前端技术类书籍是包含在IT互联网类型中，而IT互联网类型可以在整个管理系统的图书分类中找到，而图书分类这个模块是在进入图书管理系统后比较显眼的功能分类中可以找到。通过将寻找这本书的流程分化成一个个的具体模块的过程再去逐一解决这个问题就是聚合。 注意：以上事例要想实现是需要图书管理系统对于图书的分类比较明确而不是单单的将一堆图书直接聚集在一起，所以可以看出并不是在所有复杂情况下都可以使用聚合去解决问题，但是使用聚合可以解决大多数问题。 如果以上的示例还是令人感到迷惑的话我们再举一个例子。 例如：一个Web开发团队由许多人员组成，这是一个比较复杂的集体，我们如何才能清晰的知道这个集体中包含哪些人，每个人在做什么工作呢？我们需要将这个团队中包含的岗位罗列出来并将我们的对象，也就是开发人员和产品经理一一对应在相应的岗位，其中每一个开发人员或产品经理只是这个Web开发团队对象的一部分，这样划分下来我们就可以解决了这些问题。 总的来说聚合在开发过程中的作用是将分开编辑的代码聚合在一起方便调用。 5.继承 继承是实际开发过程一种比较便捷的方式，通过继承这种方式可以实现代码的重复利用。 例如：人这个对象的名称我们可以将其命名为Person，这个对象中应该包含姓名、年龄、出生日期等属性以及走路、跑步、谈话、吃饭、睡觉等方法。这时候我们想要编写一个Student对象，这个对象拥有和Person对象一样的特征，因此我们可以直接继承Person对象，这样我们只需要通过去重用Person对象去编写Student对象的实现代码部分即可。接着我们还想编写一个Teacher对象依然可以这样做。 通过以上示例就可以实现了代码的复用避免了不停地重写相同的方法和属性，做到高效利用。 在传统的面向对象的程序设计中，继承通常都是指类与类之间的关系，但是JavaScript中并不存在类这样的说法，所以它的继承是发生在对象与对象之间。 当一个对象继承另一个对象的时候，可能会继承的基础上在里面加入新的方法，这个过程被称为“继承对象扩展自被继承对象”或者“继承对象继承自被继承对象”。比如A对象继承B对象，那么就是“A扩展自B”或“A继承自B”。此外我们也可以重新定义被继承的对象中的方法，被重新定义后的方法只是改变了当前继承在该对象中的方法，并不会真正改变被继承对象中的方法，而这种重新定义继承过来的方法的过程叫做方法的覆写。 6.多态 还是上面的例子，Student对象继承了Person对象中所有的方法，Teacher对象也继承了Person对象中所有的方法，拿方法中的跑步举例，跑步是“run”方法，这时候代码中有一个叫做Jack的变量，我们并不知道Jack是属于Person对象还是属于Student对象还是属于Teachar，在这种情况下我们还是可以去调用对象的“run”方法，实现跑步这一方法，形如这种通过相同的方法调用来实现各自行为的能力的就是多态。如果再通俗来讲，就是同一个操作作用在不同的对象上产生不同的解释或者是不同的结果就是多态。 举个栗子： 12345678910111213141516 1 function Person() &#123;&#125; 2 Person.prototype.age = function(age) &#123; 3 return age; 4 &#125; 5 6 function Student() &#123;&#125; 7 Object.setPrototypeOf(Student.prototype,Person.prototype); 8 9 function Teacher() &#123;&#125;10 Object.setPrototypeOf(Teacher.prototype,Person.prototype);11 12 var stu = new Student();13 console.log(stu.age(18));14 15 var tea = new Teacher();16 console.log(tea.age(28)); 即使后面再加上一个Master对象，依然可以继续调用，不影响其它代码的调用实现 12345678910111213141516171819202122 1 function Person() &#123;&#125; 2 Person.prototype.age = function(age) &#123; 3 return age; 4 &#125; 5 6 function Student() &#123;&#125; 7 Object.setPrototypeOf(Student.prototype,Person.prototype); 8 9 function Teacher() &#123;&#125;10 Object.setPrototypeOf(Teacher.prototype,Person.prototype);11 12 function Master() &#123;&#125;13 Object.setPrototypeOf(Master.prototype,Person.prototype);14 15 let stu = new Student();16 console.log(stu.age(18));17 18 let tea = new Teacher();19 console.log(tea.age(28));20 21 let mas = new Master();22 console.log(mas.age(38));","categories":[{"name":"前端","slug":"前端","permalink":"https://codemariosec.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codemariosec.github.io/tags/JavaScript/"}]}],"categories":[{"name":"网络","slug":"网络","permalink":"https://codemariosec.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"信息安全","slug":"信息安全","permalink":"https://codemariosec.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"前端","slug":"前端","permalink":"https://codemariosec.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Pcap","slug":"Pcap","permalink":"https://codemariosec.github.io/tags/Pcap/"},{"name":"kali","slug":"kali","permalink":"https://codemariosec.github.io/tags/kali/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://codemariosec.github.io/tags/JavaScript/"}]}