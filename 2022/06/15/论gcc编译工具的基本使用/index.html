<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>论gcc编译工具的基本使用 | codeMario | 逆风赶路，不负众望</title>

  
  <meta name="author" content="codeMario">
  

  
  <meta name="description" content="一、什么是GCC编译器​    GCC是由GNU开发的编程语言编译器，GNU编译器套件包括C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等）,它可以完成上述编程语言从源文件向运行在特定CPU硬件上的目标代码的转换，GCC不仅功能非常强大，而且结构也很灵活，具有良好的便携性和跨平台支持。">
  

  
  
  <meta name="keywords" content="gcc,C/C++">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="论gcc编译工具的基本使用"/>

  <meta property="og:site_name" content="codeMario"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="codeMario" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">codeMario</a>
    </h1>
    <p class="site-description">逆风赶路，不负众望</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
        <li><a href="/about">About</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>论gcc编译工具的基本使用</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/06/15/论gcc编译工具的基本使用/" rel="bookmark">
        <time class="entry-date published" datetime="2022-06-14T16:00:01.000Z">
          2022-06-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="一、什么是GCC编译器"><a href="#一、什么是GCC编译器" class="headerlink" title="一、什么是GCC编译器"></a>一、什么是GCC编译器</h1><p>​    GCC是由GNU开发的编程语言编译器，GNU编译器套件包括C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等）,它可以完成上述编程语言从源文件向运行在特定CPU硬件上的目标代码的转换，GCC不仅功能非常强大，而且结构也很灵活，具有良好的便携性和跨平台支持。</p>
<span id="more"></span>
<h1 id="二、GCC-G-安装命令"><a href="#二、GCC-G-安装命令" class="headerlink" title="二、GCC/G++安装命令"></a>二、GCC/G++安装命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc g++ </span><br></pre></td></tr></table></figure>
<p>安装好后可以通过以下命令来查看gcc/g++版本，确定是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -v			# 查看gcc版本</span><br><span class="line">g++ -v			# 查看g++版本</span><br></pre></td></tr></table></figure>
<h1 id="三、GCC编译工具支持的文件类型"><a href="#三、GCC编译工具支持的文件类型" class="headerlink" title="三、GCC编译工具支持的文件类型"></a>三、GCC编译工具支持的文件类型</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件后缀</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.c</td>
<td style="text-align:center">C语言源程序</td>
</tr>
<tr>
<td style="text-align:center">.a</td>
<td style="text-align:center">由目标文件构成的档案库文件</td>
</tr>
<tr>
<td style="text-align:center">.C/.cc/.cxx</td>
<td style="text-align:center">C++源程序</td>
</tr>
<tr>
<td style="text-align:center">.h</td>
<td style="text-align:center">源程序包含的头文件</td>
</tr>
<tr>
<td style="text-align:center">.i</td>
<td style="text-align:center">C源代码文件且不应该对其执行预处理</td>
</tr>
<tr>
<td style="text-align:center">.ii</td>
<td style="text-align:center">C++源代码文件且不应该对其执行预处理</td>
</tr>
<tr>
<td style="text-align:center">.m</td>
<td style="text-align:center">Objective-C源程序</td>
</tr>
<tr>
<td style="text-align:center">.o</td>
<td style="text-align:center">编译后的目标文件</td>
</tr>
<tr>
<td style="text-align:center">.s</td>
<td style="text-align:center">汇编语言源代码文件</td>
</tr>
<tr>
<td style="text-align:center">.S</td>
<td style="text-align:center">经过预编译的汇编程序</td>
</tr>
</tbody>
</table>
</div>
<h1 id="四、GCC使用方法"><a href="#四、GCC使用方法" class="headerlink" title="四、GCC使用方法"></a>四、GCC使用方法</h1><p>gcc是基于Linux平台下的C语言编译器，其基本的使用语法如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc [option | fileName] [fileName] [destination fileName]</span><br></pre></td></tr></table></figure>
<p>g++是基于Linux平台下的C++语言编译器，其基本的使用语法如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ [option | fileName] [fileName] [destination fileName]</span><br></pre></td></tr></table></figure>
<h1 id="五、GCC编译工具工作流程"><a href="#五、GCC编译工具工作流程" class="headerlink" title="五、GCC编译工具工作流程"></a>五、GCC编译工具工作流程</h1><p>​    gcc由C源代码文件生成可执行文件的过程不仅仅是编译的过程，而是要经历以下步骤。</p>
<p><img src="https://codemario-picgo.oss-cn-shenzhen.aliyuncs.com/img/gcc.drawio.png" alt="gcc.drawio"></p>
<p>这里我们以helloworld.c文件为例来阐述gcc的工作流程。</p>
<p>源文件代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[NUM]=<span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the content.\n&quot;</span>);</span><br><span class="line">    fgets(s, NUM, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（1）预处理阶段</strong></p>
<p>​    预处理过程中，将源代码文件中包含的各种头文件以及预编译语句等展开生成后缀以.i结尾的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E helloworld.c -o helloworld.i</span><br></pre></td></tr></table></figure>
<p>编译生成的<code>helloworld.i</code>文件内容如图所示：</p>
<p><img src="https://codemario-picgo.oss-cn-shenzhen.aliyuncs.com/img/helloworld-i.png" alt="helloworld-i" style="zoom:67%;" /></p>
<p><strong>（2）编译阶段</strong></p>
<p>​    将预处理后以.i结尾的文件编译生成后缀以.s结尾的汇编语言代码文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S helloworld.i -o helloworld.s</span><br></pre></td></tr></table></figure>
<p>编译生成的<code>helloworld.s</code>文件内容如图所示：</p>
<p><img src="https://codemario-picgo.oss-cn-shenzhen.aliyuncs.com/img/helloworld-s.png" alt="helloworld-s" style="zoom:67%;" /></p>
<p><strong>（3）汇编阶段</strong></p>
<p>​    将以.s为后缀的汇编语言文件经过汇编后生成后缀以.o结尾的目标文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c helloworld.s -o helloworld.o</span><br></pre></td></tr></table></figure>
<p>编译生成的<code>helloworld.o</code>文件内容如图所示：</p>
<p><img src="https://codemario-picgo.oss-cn-shenzhen.aliyuncs.com/img/helloworld-o.png" alt="helloworld-o" style="zoom:67%;" /></p>
<p>​    打开文件我们看到其中的的内容是由各种特殊字符组成，汇编阶段的工作是将汇编语言的代码转换为机器码，这部分代码是可以直接被计算机所执行的，我们通过<code>file helloworld.o</code>指令查看一下该文件的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloworld.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure>
<p>我们可以得知该文件的文件格式是elf格式，elf格式的文件我们可以使用<code>readelf</code>工具查看其中内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -a helloworld.o</span><br></pre></td></tr></table></figure>
<p><img src="https://codemario-picgo.oss-cn-shenzhen.aliyuncs.com/img/readelfhelloworld-o.png" alt="readelfhelloworld-o" style="zoom:67%;" /></p>
<p><strong>（4）链接阶段</strong></p>
<p>​    将所有源文件对应的目标文件链接起来安排在可执行程序中恰当的位置，将程序中所调用的库函数链接起来，最终生成一个可执行的程序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc helloworld.o -o helloworld</span><br></pre></td></tr></table></figure>
<p>​    在实际开发过程中，我们在编译生成可执行文件时不会一步一步执行上述命令，而是直接使用下面的命令完成预处理、编译、汇编和链接生成可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc helloworld.c -o helloworld</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong></p>
<p><img src="https://codemario-picgo.oss-cn-shenzhen.aliyuncs.com/img/result.png" alt="result"  /></p>
<p>​    在上述的执行过程中，我们还需要知道的是，在链接阶段，链接的方式有两种，一种是<strong>静态链接</strong>，另一种是<strong>动态链接</strong>。</p>
<p>​    其中<strong>静态链接</strong>是在gcc链接执行代码后面加上 <code>--static</code>选项，静态链接在gcc链接时就会将程序所用到的库打包到自己的可执行程序中，无需依赖外部环境，程序兼容性比较好，但是生成的程序比较大。</p>
<p>​    <strong>动态链接</strong>是在程序运行时将外部的代码库动态加载到内存中，在gcc链接时不会将代码打包到可执行程序中，生成的程序比较小。gcc的编译链接时候默认是以动态链接的方式加载的。我们可以使用<code>ldd</code>工具去查看动态文件的库依赖。</p>
<p><img src="https://codemario-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%BE%9D%E8%B5%96.png" alt="动态链接库依赖"  /></p>
<p>​    我们由此可以得知通过动态链接生成的helloworld依赖于库文件linux-vdso.so.1、libc.so.6 以及ld-linux-x86-64.so.2。</p>
<p>​    我们可以分别以静态链接和动态链接的方式去编译链接上面的程序，并去查看一下两种方式生成的可执行文件的大小。</p>
<p><img src="https://codemario-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E5%AF%B9%E6%AF%94.png" alt="静态链接动态链接生成的文件大小对比"></p>
<p>​    动态链接生成的可执行文件大小为17k，静态链接生成的可执行文件大小为852k。</p>
<h1 id="六、GCC常用参数选项"><a href="#六、GCC常用参数选项" class="headerlink" title="六、GCC常用参数选项"></a>六、GCC常用参数选项</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">gcc编译选项</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-E</td>
<td style="text-align:center">预处理指定的源文件，不进行编译</td>
</tr>
<tr>
<td style="text-align:center">-S</td>
<td style="text-align:center">编译指定的源文件，但是不进行汇编</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:center">编译、汇编指定的源文件，但是不进行链接</td>
</tr>
<tr>
<td style="text-align:center">-o [file1] [file2] / [file2] -o [file1]</td>
<td style="text-align:center">将文件 file2 编译成可执行文件 file1</td>
</tr>
<tr>
<td style="text-align:center">-I directory</td>
<td style="text-align:center">指定 include 包含文件的搜索目录</td>
</tr>
<tr>
<td style="text-align:center">-g</td>
<td style="text-align:center">在编译的时候，生成调试信息，该程序可以被调试器调试</td>
</tr>
<tr>
<td style="text-align:center">-D</td>
<td style="text-align:center">在程序编译的时候，指定一个宏</td>
</tr>
<tr>
<td style="text-align:center">-w</td>
<td style="text-align:center">不生成任何警告信息</td>
</tr>
<tr>
<td style="text-align:center">-Wall</td>
<td style="text-align:center">生成所有警告信息</td>
</tr>
<tr>
<td style="text-align:center">-On</td>
<td style="text-align:center">n的取值范围：0~3。编译器的优化选项的4个级别，-O0表 示没有优化，-O1为缺省值，-O3优化级别最高</td>
</tr>
<tr>
<td style="text-align:center">-l</td>
<td style="text-align:center">在程序编译的时候，指定使用的库</td>
</tr>
<tr>
<td style="text-align:center">-L</td>
<td style="text-align:center">指定编译的时候，搜索的库的路径</td>
</tr>
<tr>
<td style="text-align:center">-fPIC/fpic</td>
<td style="text-align:center">生成与位置无关的代码</td>
</tr>
<tr>
<td style="text-align:center">-shared</td>
<td style="text-align:center">生成共享目标文件，通常用在建立共享库时</td>
</tr>
<tr>
<td style="text-align:center">-std</td>
<td style="text-align:center">指定C的执行版本，如:-std=c99，gcc默认的版本是GNU C</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/C-C/">C/C++</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/gcc/">gcc</a><a href="/tags/C-C/">C/C++</a>
    </span>
    

    </div>

    
  </div>
</article>

  

	<section id="comment" class="comment">
		<div id="vcomments"></div>
	</section>
	<!-- LeanCloud -->
	<script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js"></script>
	<!-- Valine -->
	<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
	<script>
		new Valine({
			el: '#vcomments',
			appId: 'WpN2taXdjtJOc4Cu7LRoQ1tO-gzGzoHsz',
			appKey: 'rWMuao9pGx49QOzohhiRN36e'
		})
	</script>






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 codeMario
    
  </p>
</footer>
    
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>